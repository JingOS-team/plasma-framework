/*
 *   Copyright Â© 2009 Rob Scheepmaker <r.scheepmaker@student.utwente.nl>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Library General Public License version 2 as
 *   published by the Free Software Foundation
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this program; if not, write to the
 *   Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef REMOTESERVICE_H
#define REMOTESERVICE_H

#include "serviceprovider_p.h"

namespace Plasma 
{

ServiceProvider::ServiceProvider(Service *service)
    : m_service(service)
{
    //we need some resource name and a redirect should be added under that name. the actual chosen
    //resource name (a number might be appended by jolie to avoid conflicts), should probably be made
    //available through a resourceName() function by the jolie adaptor, or maybe just a KUrl url()
    //since that would be convenient when wanting to announce services on the network through
    //zeroconf, and the resource name is easily obtained from there as well.
    setResourceName(service->name());
    connect(AccessManager::self(),
            SIGNAL(authorizationSuccesful(Plasma::Service *service, Jolie::Message)),
            this, SLOT(messageAuthorized(Plasma::Service *service, Jolie::Message)));
}

ServiceProvider::messageReceived(Jolie::Message message)
{
    //authorization occurs by checking the value of two children that are added to every
    //message that get's sent by RemoteService (the client side of ServiceProvider): "host"
    //(full hostname or ip) and "signature" (a digital signature made by encrypting a hash 
    //of the entire sodep message and verified by obtaining the public key from a PublicKeyService
    //running at the computer sending this message. obviously this authorization needs to be
    //async.
    AccessManager::self()->authorize(this, message);
}

ServiceProvider::sendOperationNames(Jolie::Message message)
{
    Jolie::Message response(resourceName(), message->operationName(), message->id());
    foreach (const QString &operationName, m_service->operationNames()) {
        response.children("operationNames") << Jolie::Value(operationName);
    }
    sendMessage(response);
}

ServiceProvider::sendOperationDescription(Jolie::Message message)
{
    QByteArray operationDescription = //serialize the operationDescription KConfigGroup. Hmm, reading the KConfigGroup apidox this seems rather ugly. It looks like it can only be done by using a KSharedConfig to write to a temporary file, and read that. Let's hope I'm wrong :p
    Jolie::Message response(resourceName(), message->operationName(), message->id());
    response.setData(Jolie::Value(operationDescription));
    sendMessage(response);
}

ServiceProvider::startOperationCall(Jolie::Message message)
{
    KConfigGroup description = //deserialize the KConfigGroup
    m_service->startOperationCall(description);
    //map finished signal through signalmapper to include the message, and connect to
    //operationCompleted slot.
}

ServiceProvider::messageAuthorized(Plasma::Service *service, Jolie::Message message)
{
    if (service != this) {
        return;
    }

    //would be lovely if this kind of stuff could be autogenerated code from xml like in dbus adaptors 
    if (message.operationName() == "getOperationNames") {
        sendOperationNames(message);
    } else if (message.operationName() == "getOperationDescription") {
        sendOperationDescription(message);
    } else if (message.operationName() == "startOperationCall") {
        startOperationCall(message);
    }
}

ServiceProvider::operationCompleted(Plasma::ServiceJob *job, Jolie::Message message)
{
    Jolie::Message response(resourceName(), message->operationName(), message->id());
    response.setData(Jolie::Value(job->reply())); //convert first to one of the 3 supported sodep message types. double or int as values, serialize the variant otherwise
    if (Jolie::Value(job->error())) {
        reponse.children("error") << Jolie::Value(job->error());
    }
    sendMessage(response);
}

} //namespace Plasma

#include "serviceprovider_p.moc"

#endif //SERVICEPROVIDER_H
